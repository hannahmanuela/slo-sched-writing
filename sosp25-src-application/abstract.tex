\begin{abstract}
    
Widely-used container orchestration systems like Kubernetes are surprisingly
unable to honor the reservations of LC applications in the presence BE workloads
for tasks that are CPU-intensive. This paper traces this problem down to Linux's
cgroups, and show that because Linux uses per-core runqueues, its weight-based
interface is not enforced across cores.

This paper proposes an API that separates best effort workloads from critical
ones with reservations by introducing the BeClass priority class. BeClass
requires fewer cross-core interactions than a weight-based approach, and ensures
that no BE is ever running when an LC is queued. During high load this requires
`parking', which enforces that BEs user-space code doesn't run if doing so would
interrupt an LC process, but continues to run kernel-level services for the BE
so that when load goes down it can continue to run.

Experiments with a BeClass implementation in Linux show that BeClass ensures LC
processes' access to their reserved cores, while running BE workloads
opportunistically. When using cgroups weights, a Kubernetes server's mean
latency jumped from 6.2ms to $\sim$13ms after starting a BE image resize job,
while using BeClass for the BE reduced the same application's mean latency
increase to 0.


\end{abstract}
