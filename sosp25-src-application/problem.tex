
\section{Problem \& Background}

All Open Container Initiative (OCI) compliant containers, including Kubernetes,
Docker, CRI-O, and containerd, enforce CPU reservations using \cgroups{}' weight
interface~\cite{oci-cgroups, docker-docs-cgroups, container-isolation-article},
as do VM frameworks, including Firecracker, AFaas and
libvirt~\cite{firecracker-cgroups,afaas,libvirt-cgroups}. Kubernetes creates one
group for all BE services, given the lowest weight 1, and pods with reservations
are in separate groups with higher weights (in the experiment the server
requested 4 CPUs and Kubernetes assigned it a pod with weight 157).\

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{graphs/srv-bg-weight-cmp-low.png}
    \caption{ the weight of the server has little impact on how much the
    weight 1 BE task interferes }\label{fig:srv-bg-weight-cmp}
\end{figure}


A simplified experiment shows \cgroups{} weights are unable to enforce
reservations. We run an open-loop client on a remote machine, with a simple LC
CPU-bound server and BE image resize job sharing four cores, each in their own
group. \cgroups{} supports weights in the range of [1,10000],
\autoref{fig:srv-bg-weight-cmp} shows that running the server with different
weights has no effect on the latency impact of the BE task.

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{graphs/schedviz-problem.png}
    \caption{Core 6 runs an image resize process, unaware that the other cores
    have queued server threads}\label{fig:schedviz-problem}
\end{figure}

The latency impact on the LC happens because the BE occasionally runs
uncontended on one core, while another has queued server threads.
\autoref{fig:schedviz-problem} shows this happening in the trace: on core 6, the
red process running for 10ms is a BE thread, while server threads, in shades of
blue, are queued on the other cores.

This priority inversion happens because weights are only enforced within
runqueues, which are per-CPU. Although load balancing eventually remedies this,
it runs less frequently than scheduling does. For workloads with request
processing times in the millisecond range, waiting for the load balancer to run
influences final processing times.

In order to globally enforce weights, each scheduling decision would require a
search of all runqueues for potentially higher-weight processes, which is too
costly. 




