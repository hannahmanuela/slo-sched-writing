\section{Design \& Implementation}

We design a new scheduling class \beclass{} that sits at a lower priority than
\normalclass{}, which enforces LC applications' uncontended access to the CPUs
they reserved. Doing so allows the LC microservices to stay in the same
scheduling class they were before, while getting the benefits of strict
prioritization across scheduling classes.

The goal of the implementation is to enforce that no \beclass{} userspace
process is ever running on cores reserved for a \normalclass{} workload if a
\normalclass{} process is queued. The scheduler enforces the priorities in three
different places:
\begin{enumerate}
    \item \local: on each core it ensures that no \beclass{} process is chosen
        if there is a runnable \normalclass{} process,
    \item \entry: before enqueuing a \normalclass{} process, a core looks for
        other cores running \beclass{} entities to interrupt,
    \item \exit: when the last \normalclass{} process on a core's queue blocks
        or exits, the core tries to steal queued \normalclass{} processes from
        other cores before running a \beclass{} process.
\end{enumerate}

Scheduling \textit{classes} in Linux can have multiple \textit{policies}. In
order to implement \beclass{} in Linux, we build on \schedidle{}, an existing
scheduling \textit{policy} in the \normalclass{}. We do so because \schedidle{}
has some of the features we want for \beclass{}. 

One feature is that \schedidle{} was extended to be accessible via the
\cgroups{} API recently~\cite{lkml-idle-cgroup}: a whole groups' policy can be
set to \schedidle{} via the \cgroups{} interface. The other is that Linux
developers also added what is in effect the \entry{} check from the \beclass{}
design~\cite{fixing-idle-article}.

Our implementation adds the \local{} and \exit{} parts of the \beclass{} design.
