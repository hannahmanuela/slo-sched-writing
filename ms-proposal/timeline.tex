%!TeX root = SM_Thesis_Proposal.tex

\section{Timeline}
\label{sec:timeline}

\textbf{Choosing the problem:} We landed on this problem space about a year ago.
The choice was motivated by multiple experiences of confusing performance
results in other projects, which pointed to a gap between expectation and
reality of Linux's cgroup interface.

\textbf{Understanding existing systems:} This happened around the past fall this
spring, and included reading up on Linux's design as well as actual code, and
running a bunch of benchmarks and experiments to understand the dynamics of
Linux's behavior as well as the reasons for the observed performance
discrepancies.

\textbf{Understanding the solution space:} This has happened throughout this
past spring and summer. We answered the question of whether this is even
possible in the timelines that Linux operates at by experimenting with existing
options in the Linux scheduler (concretely, by making use of Linux's real time
scheduler). We then ran further more complex experiments to understand the
implications of running workloads in the real time scheduler, and came to the
conclusion that this was not a viable solution. We landed on the option of
creating a new scheduling class. 

\textbf{Implementing the change:} There are multiple ways to go about
implementing this change in something as big and complicated as Linux. In the
past month we experimented with different approaches and ended up landing on the
choice of enhancing Linux's treatment of \schedidle{}. This involved choosing
between a tradeoff: creating the more intellectually clean but code-wise
invasive change of a whole new scheduling class, vs choosing to reuse the
existent special-casing of \schedidle{} and building it out with the one main
missing feature to have it effectively be a separate scheduling class. We chose
the latter, and spent the past couple weeks implementing the patch and testing
it in our microbenchmark settings. 


\textbf{Measuring the change:} In the time between now and the deadline, we plan
to further understand and push the solution. This includes three main
dimensions: we want to measure the exact costs (how long does the added code
take to run); we want to understand its implications (do things break when BE
processes are starved for longer periods of time); and finally we want to create
more realistic and end-to-end scenarios to understand the practical implications
of the change we made.


