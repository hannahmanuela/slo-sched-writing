\section{Solution?}\label{s:maybe-solution}

We implement a new category for processes to be in, which we call \schedbe{},
which exist in relation to the default scheduling policy, \schednormal{}. The
goal is to create \schedbe{} so that the modified kernel enforces the goal that
no \schedbe{} is ever running if a \schednormal{} task is waiting for a core.
The patch intervenes in a couple places:
\begin{enumerate}
    \item in picking the next entity on each runqueue, it ensures that no
\schedbe{} entity will be chosen if there is a runnable \schednormal{} entity,
    \item it tries to steal queued \schednormal{} entities from other cores
before running a \schedbe{} entity,
    \item when waking up a \schednormal{} entities on a core already running a
    \schednormal{} entity, it looks for other cores running \schedbe{}
    entities to go interrupt.
\end{enumerate}

These three pieces together create the desired strict and global priority. The
first change ensures that on each runqueue \schedbe{} will never run when there
is a runnable \schednormal{}. The second and third that no core is ever running
a \schedbe{} process while a \schednormal{} one is runnable and waiting. This is
because in order to enforce a categorical priority, the scheduler only needs to
sychronize at two points: on \textit{entry}, when a new high-priority thread
wakes up on a core already running something high-priority, and \textit{exit},
when starting to run a low priority thread.

\subsection{Intra-runqueue unfairness}

In order to enforce that ruqueues only run \schedbe{} threads when there are no
runnable \schednormal{} ones, the patch interferes in two places. The first is
the actual function that chooses the next task, where new code initially
establishes whether there are any \schednormal{} threads on the runqueue, and
skips any \schedbe{} ones if that is the case. 

The second change is necessary because the first throws the fair share
eligibility mechanism out of whack. In order to maintain fairness, Linux
currently accounts for the difference between the fair share processes should
have gotten and the time they actually got, and stores that `lag'. Even low
weight processes accrue lag over time, albeit more slowly. Since \schedbe{}
threads are now potentially not being run for a long time, there is a potential
for deadlock: a \schednormal{} task has been running for a while and accrued
enough time that its lag is negative and it is ineligible. However, if the only
other thread is \schedbe{} then we won't run that either. In order to avoid this
situation, the patch removes the eligibility criterion in choosing what to run
next.


\subsection{Inter-runqueue unfairness}


Ensuring the exit and entry path requires interposing on both. The existing code
already special-cases on the wakeup path, although only checks if the thread
itself is marked as idle, and not if the group as a whole is. The patch fixes this.

The patch also adds a check on the exit: if the thread chosen to run next is
\schedbe{}, then the patch tries to steal a queued \schednormal{} task from a
different core. Specifically, it picks the core with the max number of queued
but runnable \schednormal{} threads, but only steals one. This is in order to
not overzealously steal, given that it is the load blanacers job to ensure that
in general load is well balanced. The stealing is just a stop-gap measure.


\hmng{at what point do I go into how these things relate to the existing
scheduling classes/policies? obviously it needs to be after I introduce them,
but if I do that in the eval that's not really an appropriate place to be going
back into how exactly the patch works?}

