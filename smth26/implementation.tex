\section{Implementation}\label{s:implementation}


In order to implement \beclass{} in Linux, we build on \schedidle{}, an existing
scheduling \textit{policy} in Linux. This is because \schedidle{} already has
some of the features we want from \beclass{}.

\subsection{\schedidle{} lends itself well to \beclass{}}

Scheduling \textit{classes} in Linux can have multiple \textit{policies}, and
\schedidle{} lives within the \normalclass{} class alongside the default policy
of the \normalclass{} class, which is \schednormal{}.\footnote{There is, very
confusingly, also an Idle scheduling \textit{class}, but that not accessible to
userspace and exists solely to manage the core's transition in and out of being
actually idle (ie running nothing).} The existing \schedidle{} policy is in many
ways not different from a low weight \schednormal{} process: both are kept on
the same runqueues as all the other \schednormal{} processes, and \schedidle{}
just has a predefined low weight of 3~\cite{weight-idleprio}.

One way that \schedidle{} is promising as a foundation for our implementation of
\beclass{} is that \schedidle{} was extended to be accessible via the \cgroups{}
API recently~\cite{lkml-idle-cgroup}: a whole groups' policy can be set to
\schedidle{} via the \cgroups{} interface. This means that building on
\schedidle{} allows us to get for free the ability to use the \cgroups{} API to
mark groups as BE. We thus have two ways to mark things as BE: we can mark
individual processes by setting their policy to \schedidle{}, or we can do so
for a whole group via the \cgroups{} API.

An additional benefit to using \schedidle{} as the foundation for our
implementation is that, after a push by Facebook, Linux developers already added
what is in effect the \entry{} check from the \beclass{}
design~\cite{fixing-idle-article}. In 2019, Linux added a check when a
\schednormal{} entity becomes newly runnable on a core already running something
in \schednormal{}. This new check looks for other cores that might be currently
running a \schedidle{} entity, and migrates the new entity there.

\subsection{\schedbe{} as an implementation of \beclass{}}

To implement \beclass{}, we modify \schedidle{} to add the \local{} and \exit{}
parts of the \beclass{} design. We call the resulting policy \schedbe{}. While
it is technically still a policy, it implements the desired behavior of
\beclass{}, and as a result behaves as if it was a scheduling class. Our
implementation is a patch to Linux version 6.14.2, which implements the
\beclass{} class by extending \schedidle{} to become \schedbe{}.

To enforce the \local{} part of the design, which calls for the local (ie single
runqueue) isolation of \schedbe{} processes, we ensure that the task chosen to
run from the runqueue is only \schedbe{} if everything else on the runqueue is
as well (\autoref{ss:implementation:local}). To enforce the \exit{} check, we
add a synchronization point to complete the global policy enforcement
(\autoref{ss:implementation:exit}).

\subsection{Enforcing the local policy}\label{ss:implementation:local}

In order to enforce that ruqueues only run \schedbe{} threads when there are no
runnable \schednormal{} ones, the patch interferes in two places. 

Because in existing Linux \schedidle{} and \schednormal{} share a runqueue, so
will the new \schedbe{} and \schednormal{}.\hmng{I mean I guess they don't have
to... would make migration and all that stuff roll your own though} This means
that the function that chooses the next task from the runqeueue will be
potentially looking at a mix of both. We add an initial check that establishes
whether there are any \schednormal{} threads on the runqueue, and skips all
\schedbe{} ones if that is the case. 

The second change is necessary because the first breaks an existing eligibility
mechanism. In order to maintain fairness, Linux currently accounts for the
difference between the fair share processes should have gotten and the time they
actually got, and stores that `lag'. Processes that have gotten more time than
they should (ie have negative lag), are marked as ineligible and not considered
when choosing what to run next. Since \schedbe{} threads are now potentially not
being run for a long time, there is a potential for deadlock: a \schednormal{}
task has been running for a while and accrued enough time that its lag is
negative and it is ineligible. However, if the only other thread is \schedbe{}
then we won't run that either because there is a runnable \schednormal{} task on
the runqueue. In order to avoid this situation, the patch removes the
eligibility criterion in choosing what to run next.


\subsection{Enforcing the global policy}\label{ss:implementation:exit}

Ensuring the \entry{} and \exit{} checks requires interposing on Linux's wakeup
and exit codepaths. Linux already special-cases on the wakeup path, although
only checks if the thread itself is marked as idle, and not if the group as a
whole is, and for \schedbe{} we check both.\hmng{this is not exactly true, but
in a kinda complicated way}

\schedbe{} adds a check on the exit path: if the thread chosen to run next is
\schedbe{}, then the patch tries to steal a queued \schednormal{} task from a
different core. Specifically, it picks the core with the max number of queued
but runnable \schednormal{} threads --- but only steals one, in order to not
overzealously steal. Linux does the same thing when a core would otherwise go
completely idle.