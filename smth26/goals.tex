%-------------------------------------------------------------------------------
\section{Goals}
\label{s:goals}
%-------------------------------------------------------------------------------


Developers use the different quality of service (QOS) classes that Kubernetes
supports to run different services with different latency needs.

The highest QOS class is Guaranteed. Guaranteed services are guaranteed access
to the number of CPUs they request, but are also limited to them. They are the
last to be evicted under resource pressure, and are used for critical
infrastructure like databases or core microservices~\cite{reddit-kub-qos}. When
using this QOS class, because there is also a limit, developers provision for
peak load.

The middle QOS class is Burstable. Burstable services are similarly guaranteed
access to the number of CPUs they requested, but are also allowed to use CPUs
beyond their reservation opportunistically. This is the category in which a web
server would be expected to run, where it can make use of the bursting in
moments of higher load. As a result, developers can provision for closer to
average load; as long as there are not too many services bursting at the same
time, each will be able to use slack of other services to handle the bursting
load.

The lowest QOS class is BestEffort. BestEffort services are only allowed to run
on resources that would otherwise go idle. For instance, if a CPU has completely
run out of Burstable and Guaranteed things to run, it should run BestEffort
threads. This is the QOS class that a developer would run background data
analytics or image resize jobs, where the time to completion is inconsequential.

In Kubernetes, the reservations and limits are expressed by attaching resource
`requests' and `limits' to pods. These are expressed as a number of vCPUs, and
can be fractional (\ie{} a pod could request 0.5 vCPUs). Pods are BestEffort if
their request is 0, and are Guaranteed if they have both a request and a limit
and those two are the same.

